# 240328

러스트 정리 (8)

## 1. 패키지와 크레이트

### 1.1 크레이트
라이브러리나 실행 가능한 모듈로 구성된 것

컴파일을 실행할 때 고려하는 가장 작은 코드 단위이다.

여러 모듈을 담을수 있다.

모듈은 크레이트와 함께 컴파일 되는 다른 파일들에 정의되어있을 수 있다.

크레이트는 둘 중 하나를 가리킨다. 러스트에서 크레이트를 주로 라이브러리(라이브러리 크레이트)와 혼용해서 사용한다.

1. 바이너리 크레이트: 
   - 커맨드 라인 프로그램이나 서버처럼 실행 가능한 실행 파일로 컴파일할 수 있는 프로그램.
   - main 함수를 포함하고 있어야한다.
   - `cargo new {binary}`
   - `src/{binary}.rs`
2. 라이브러리 크레이트
   -  main 함수를 포함하지 않음. 실행파일 형태로 컴파일 되지 않는다.
   - `cargo new --lib {library}`
크레이트 루트는 러스트 컴파일러가 컴파일을 시작하는 소스 파일을 가리킨다.

### 1.2. 패키지
크레이트를 빌드하고, 테스트하고, 공유하는 데 사용하는 카고 기능이다. 

일련의 기능을 제공하는 하나 이상의 크레이트로 구성된 번들을 가리킨다.

패키지에는 크레이트들을 빌드하는 방법이 설명된 파일이 포함되어있다.
- Cargo.toml


> 패키지에는 여러 개의 바이너리 크레이트가 원하는 만큼 포함될 수 있지만, 라이브러리 크레이트는 하나만 넣을 수 있습니다. 패키지에는 적어도 하나 이상의 크레이트가 포함되어야 하며, 이는 라이브러리든 바이너리든 상관없습니다.

### 1.3. 모듈, use
구조, 스코프를 제어하고, 조직 세부 경로를 감추는 데 사용한다. 

**use** 키워드

특정 스코프 내에서 긴 경로의 반복을 줄이기 위해 사용한다.
- **as** 키워드: 별명을 지어줄수 있다.(파이썬과 같음)

**pub** 키워드
모듈을 공개하기 위해 사용한다. 기본값은 비공개(private)

다른 파일에서 사용하기 위해선 필요한 모듈(모듈, 구조체, 필드 등) 모두 pub 설정해줘야 사용가능하다.

형제 관계에 있는 경우는 비공개여도 사용할수 있다.

**mod** 키워드
모듈 선언시 사용한다.

모듈 선언시 코드를 탐색하는 위치가 정해져있다.
- `mod {name} { /\*inline code\*/ }`
- `src/{name}.rs` 파일 안
- `src/{name}/mod.rs` 파일 안

크레이트 루트 파일이든 아니든 똑같이 사용한다.
- 크레이트 루트 파일 안에서 선언한 건 모듈
- 크레이트 루트 파일이 아니면 서브 모듈

### 1.4.경로
구조체, 함수, 모듈 등의 이름을 지정한다.

1. 절대 경로 (absolute path): 크레이트 루트로부터 시작되는 전체 경로이다
   - 외부 크레이트로부터의 코드에 대해서는 해당 크레이트 이름으로 절대 경로가 시작되고 현재의 크레이트로부터의 코드에 대해서는 crate 리터럴로부터 시작된다.

2. 상대 경로 (relative path): 현재의 모듈을 시작점으로 하여 self, super 혹은 현재 모듈 내의 식별자를 사용한다.

어떤 경로를 사용할진 알아서 선택해야한다.
   - 일반적으로 선호하는 경로는 절대 경로이다.
   - 아이템을 정의하는 코드와 호출하는 코드는 분리되어 있을 가능성이 높기 때문이다.
   - 파이썬에서 라이브러리 임포트할땐 절대경로로 했던 것 같긴하다. 
     - `from file.module.submodule import method` 이런느낌
    
## 2. 컬렉션

컬렉션은 모두 힙에 저장되는 데이터라고 한다.

### 2.1. 벡터 Vector

```rust
// Vec<T>
fn main() {
    let v: Vec<i32> = Vec::new();
}
```

- 배열이랑은 비슷하지만 다르다.
- c++의 벡터생각하면 될 듯하다.

### 2.2. 문자열 String

```rust
// String
fn main() {
    let mut s = String::new();
}
```
- UTF-8
- `push_str`, `push`: 문자열 추가
- 문자열(String)은 인덱싱을 지원하지 않는다.
   - UTF-8 을 지원해서 유니코드의 스칼라값이 2바이트를 차지하므로 인덱스와 항상 대응하지 않기때문이다.
- 문자열 슬라이싱은 가능하다. `s[0..4]`
- `s.chars()`를 사용해서 문자열에 대한 iterator를 만들수 있다.

### 2.3. 해시맵 Hash map

```rust
// HashMap<K, V>
use std::collections:HashMap;

fn main() {
    let mut ss = HashMap::new();
}
```

- 파이썬 딕셔너리, c++ 해시맵과 같은 기능을 갖는다고 생각하면 된다.
- `hm.insert()` 값 추가 
- `hm.get()` 키 값 접근
- `hm.entry()`: 키 존재유무 확인 


---

[https://doc.rust-kr.org/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html](https://doc.rust-kr.org/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)

[https://doc.rust-kr.org/ch08-00-common-collections.html](https://doc.rust-kr.org/ch08-00-common-collections.html)

[https://doc.rust-lang.org/std/collections/index.html](https://doc.rust-lang.org/std/collections/index.html)

- 표준 라이브러리 컬렉션은 여기서 확인!